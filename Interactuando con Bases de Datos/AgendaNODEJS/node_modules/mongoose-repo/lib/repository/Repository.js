/**
 *  Creator: Christian Hotz
 *  Company: hydra newmedia GmbH
 *  Date: 08.06.16
 *
 *  Copyright hydra newmedia GmbH
 */
"use strict";
/**
 *  Imports
 */
var _ = require('lodash');
var async = require('async');
var be_utils_1 = require('be-utils');
var be_utils_2 = require('be-utils');
var ResultList_1 = require('./models/ResultList');
var OrCondition_1 = require('./OrCondition');
var Repository = (function () {
    /**
     *  Class constructor of Repository
     */
    function Repository(collection, loggerOrLogDir) {
        this.collection = collection;
        this.collectionName = this.collection.modelName;
        if (_.has(loggerOrLogDir, 'baseDir')) {
            this.logger = (new be_utils_1.LoggerFactory(loggerOrLogDir)).createWinstonLogger();
        }
        else {
            this.logger = loggerOrLogDir;
        }
    }
    Repository.prototype.insert = function (model, callback) {
        var _this = this;
        this.collection.create(model, function (err, insertedModel) {
            if (err || !insertedModel) {
                var returnError = new be_utils_2.Error(100, 'insertError', 'error while inserting the model', 'Repository.insert', err);
                // "code":11000" => "errmsg":"E11000 duplicate key error index: ... "
                if (err.code === 11000) {
                    returnError.code = 101;
                    returnError.name = 'duplicateError';
                    returnError.message = 'model already exists with the given unique property';
                }
                _this.logger.error('Repository - could not insert model "' +
                    JSON.stringify(model, null, 4) + '", error: "' + JSON.stringify(err, null, 4) + '"');
                return callback(returnError);
            }
            else {
                _this.logger.debug('Repository - inserted "' + _this.collectionName + '"-model with new id: "' +
                    insertedModel._id + '" into the collection');
                return callback(null, insertedModel);
            }
        });
    };
    Repository.prototype.update = function (id, model, callback) {
        var _this = this;
        this.logger.debug('Repository - about to save "' + this.collectionName + '"-model by id "' + id + '" and data: ', model);
        this.collection.findByIdAndUpdate(id, model, Repository.FIND_UPDATE_OPTS, function (err, updatedModel) {
            if (err) {
                var returnError = new be_utils_2.Error(102, 'updateError', 'error while updating the model', 'Repository.update', err);
                return callback(returnError);
            }
            else {
                _this.logger.debug('Repository - updated "' + _this.collectionName + '"-model by id "' + updatedModel._id + '"');
                return callback(null, updatedModel);
            }
        });
    };
    Repository.prototype.updateByCondition = function (cond, model, callback) {
        var _this = this;
        this.collection.findOneAndUpdate(cond, model, Repository.FIND_UPDATE_OPTS, function (err, updatedModel) {
            if (err) {
                var returnError = new be_utils_2.Error(102, 'updateError', 'error while updating the model', 'Repository.updateByCondition', err);
                return callback(returnError);
            }
            else {
                _this.logger.debug('Repository - updated "' + _this.collectionName + '"-model by condition: "' + JSON.stringify(cond) + '"');
                return callback(null, updatedModel);
            }
        });
    };
    Repository.prototype.updateBulk = function (keys, models, callback) {
        var _this = this;
        this.logger.info('Repository.updateBulk - about to update ' + models.length + ' "' + this.collectionName + '"-models');
        /*
            Example:
                        
            var bulk = People.collection.initializeOrderedBulkOp();     // init the bulk-object
                bulk.find(query).update(update);                        // find an object by the {query} and update it
                bulk.execute(function (error) {                         // execute the bulk
                    callback();                                         // handle the callback
                });
        */
        // init bulk update
        var bulkUpdate = this.collection.collection.initializeOrderedBulkOp();
        async.each(models, function (model, asyncCallback) {
            var or = new OrCondition_1.OrCondition(keys);
            var condition = or.add(model).build();
            // if keys exist and the model could be found
            if (!or.isEmpty()) {
                // then build the query to find the object to replace it by the {model} or upsert if not existent
                bulkUpdate.find(condition).upsert().replaceOne(model);
            }
            else {
                // else, ino query is built, then just insert the {model}
                bulkUpdate.insert(model);
            }
            asyncCallback();
        }, function (err) {
            if (err) {
                if (err instanceof be_utils_2.Error) {
                    return callback(err);
                }
                else {
                    var returnError = new be_utils_2.Error(102, 'updateError', 'error while preparing the bulk', 'Repository.updateBulk', err);
                    return callback(returnError);
                }
            }
            else {
                // execute the bulk
                bulkUpdate.execute(function (error) {
                    if (error) {
                        var returnError = new be_utils_2.Error(102, 'updateError', 'error while executing the bulk', 'Repository.updateBulk', error);
                        return callback(returnError);
                    }
                    else {
                        _this.logger.debug('Repository.updateBulk - bulk-updated models');
                        return callback(null);
                    }
                });
            }
        });
    };
    Repository.prototype.findOne = function (cond, callback) {
        var _this = this;
        this.collection.findOne(cond, function (err, foundModel) {
            if (err || !foundModel) {
                return callback(new be_utils_2.Error(103, 'repositoryFindError', 'error while searching a model', 'Repository.findOne', err));
            }
            else {
                _this.logger.debug('Repository - found "' + _this.collectionName + '"-model with id ' + foundModel._id +
                    ' (search-conditions: ' + JSON.stringify(cond) + ')');
                return callback(null, foundModel);
            }
        });
    };
    Repository.prototype.findById = function (id, callback) {
        var _this = this;
        this.collection.findById(id, function (err, foundModel) {
            if (err || !foundModel) {
                return callback(new be_utils_2.Error(103, 'repositoryFindError', 'error while searching a model by id', 'Repository.findById', err));
            }
            else {
                _this.logger.debug('Repository - found "' + _this.collectionName + '" model by searching for id ' + foundModel._id);
                return callback(null, foundModel);
            }
        });
    };
    Repository.prototype.findAll = function (callback, limit, offset) {
        this.find({}, callback, limit, offset);
    };
    Repository.prototype.find = function (cond, callback, limit, offset) {
        var _this = this;
        this.logger.debug('Repository - find "' + this.collectionName + '"-model with search-conditions ' + JSON.stringify(cond));
        if (_.has(cond, 'id')) {
            _.set(cond, '_id', _.get(cond, 'id'));
            _.unset(cond, 'id');
        }
        var findQuery = this.collection.find(cond);
        if (limit && limit > 0) {
            findQuery.limit(limit);
        }
        if (offset && offset > 0) {
            findQuery.skip(offset);
        }
        findQuery.exec(function (err, foundModels) {
            if (err || !foundModels) {
                return callback(new be_utils_2.Error(103, 'repositoryFindError', 'error while searching for models', 'Repository.find', err));
            }
            else {
                _this.collection.count(cond).exec(function (err, count) {
                    if (err || !_.isFinite(count)) {
                        return callback(new be_utils_2.Error(103, 'repositoryFindError', 'error while counting models matching search', 'Repository.find', err));
                    }
                    else {
                        var documents_1 = [];
                        async.each(foundModels, function (foundModel, asyncCallback) {
                            if (foundModel && _.has(foundModel, '_doc')) {
                                foundModel = _.get(foundModel, '_doc');
                            }
                            _this.cleanupEmbeddedDocuments(foundModel);
                            documents_1.push(foundModel);
                            asyncCallback();
                        }, function () {
                            var result = new ResultList_1.ResultList(documents_1, count, limit, offset);
                            _this.logger.debug('Repository - found "' + _this.collectionName + '" models');
                            return callback(null, result);
                        });
                    }
                });
            }
        });
    };
    Repository.prototype.cleanupEmbeddedDocuments = function (doc) {
        var _this = this;
        _.keys(doc).forEach(function (key) {
            var property = doc[key];
            if (_.isArray(property) && !_.isEmpty(property)) {
                _.forEach(property, function (item, idx) {
                    if (item.constructor.name === 'EmbeddedDocument') {
                        property[idx] = item.inspect();
                    }
                });
            }
            else if (_.isObject(property) && !_.isEmpty(property)) {
                _this.cleanupEmbeddedDocuments(property);
            }
        });
        return doc;
    };
    Repository.FIND_UPDATE_OPTS = {
        'new': true,
        'upsert': true
    };
    return Repository;
}());
exports.Repository = Repository;
